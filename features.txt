Nice — solid idea and a very achievable MVP if you stay ruthless about scope. I’ll keep this practical and ordered so you can implement it straightaway in Next.js + TypeScript + Supabase. I won’t add bells you can’t complete fast — just the minimal pieces to make a working tournament app with DUPR-based seeding, live scoring, and a referee flow.

---

# MVP scope (what to build right now)

**Must-haves (MVP)**

1. Create Tournament (name, date, format: single-elimination, num players)
2. Register Players (name, email, DUPR rating)
3. Generate Bracket / Fixtures automatically from DUPR (single-elimination; handle byes)
4. Referee / Score UI: view match, submit score for a match
5. Live updates: scoreboard updates in real-time via Supabase Realtime (or subscriptions)
6. Minimal pages: Tournament list, Tournament detail (bracket + matches), Register player modal/page, Referee match page

**Exclude for MVP (later)**

* Double elimination / consolation brackets
* Paid registration / payments
* Advanced seeding rules (runs, gender divisions, complex round-robin)
* Player profiles, ranking updates, match history analytics
* Fancy UI transitions — keep it functional

---

# Data model (Supabase / Postgres SQL)

Create these core tables. I keep columns minimal but extensible.

```sql
-- tournaments
create table tournaments (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  date timestamptz,
  format text not null default 'single-elim',
  created_at timestamptz default now()
);

-- players (people you can register)
create table players (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  email text,
  dupr numeric, -- e.g. 1.00 - 7.00 (use numeric or float)
  created_at timestamptz default now()
);

-- registrations (player entered into a particular tournament)
create table registrations (
  id uuid primary key default gen_random_uuid(),
  tournament_id uuid references tournaments(id) on delete cascade,
  player_id uuid references players(id) on delete cascade,
  seed integer, -- assigned after seeding (1 = top seed)
  created_at timestamptz default now()
);

-- matches (fixtures)
create table matches (
  id uuid primary key default gen_random_uuid(),
  tournament_id uuid references tournaments(id) on delete cascade,
  round integer not null, -- 1 = first round, higher = later rounds
  slot_a uuid references players(id), -- can be null for BYE
  slot_b uuid references players(id),
  seed_a integer,
  seed_b integer,
  winner uuid references players(id),
  status text default 'scheduled', -- scheduled | live | finished
  scheduled_at timestamptz,
  created_at timestamptz default now()
);

-- scores (store per-match scoring history)
create table match_scores (
  id uuid primary key default gen_random_uuid(),
  match_id uuid references matches(id) on delete cascade,
  scorer_id uuid references players(id), -- user/referee who submitted
  score_json jsonb, -- e.g. {"games":[{"a":11,"b":8}, {"a":9,"b":11}, {"a":11,"b":7}]}
  created_at timestamptz default now()
);
```

---

# TypeScript types (for Next.js + Supabase client)

```ts
type Tournament = {
  id: string
  name: string
  date?: string
  format: 'single-elim'
}

type Player = {
  id: string
  name: string
  email?: string
  dupr?: number
}

type Registration = {
  id: string
  tournament_id: string
  player_id: string
  seed?: number
}

type Match = {
  id: string
  tournament_id: string
  round: number
  slot_a?: string | null
  slot_b?: string | null
  seed_a?: number | null
  seed_b?: number | null
  winner?: string | null
  status: 'scheduled'|'live'|'finished'
}
```

---

# Seeding & bracket generation (concept + simple TS implementation)

**Principles**

* DUPR: higher DUPR = stronger. Seed descending (highest DUPR = seed 1).
* For `N` players, build the next power-of-two bracket and assign byes to top seeds using standard bracket seeding (1 vs N, 2 vs N-1, etc).
* Single-elim bracket generation: generate pairings for round 1, then create match rows for future rounds with empty slots referencing earlier match winners.

**Simplified algorithm (seed players, create first-round matches)**

```ts
function seedPlayers(players: {id: string, dupr: number}[]) {
  // sort descending dupr (higher first)
  return [...players].sort((a,b)=> (b.dupr ?? 0) - (a.dupr ?? 0));
}

function generateBracketSeeds(seededPlayers: {id:string}[]) {
  const n = seededPlayers.length;
  // next power of two
  let size = 1;
  while (size < n) size <<= 1;
  const byes = size - n;

  // standard seeding order for first round (1 vs size, 2 vs size-1, etc)
  const seeds: (string|null)[] = new Array(size).fill(null);
  for (let i=0;i<n;i++) seeds[i] = seededPlayers[i].id;

  // pair indices: (0,size-1), (1,size-2) ...
  const matches = [];
  for (let i=0;i<size/2;i++) {
    const a = seeds[i] ?? null;
    const b = seeds[size - 1 - i] ?? null;
    matches.push({slotA: a, slotB: b});
  }
  return {size, byes, matches};
}
```

**Byes handling**

* If `slotB` is `null` (bye), mark match as auto-won by `slotA` and advance them to next round.

---

# Live score + referee flow

* **Referee UI**: list of assigned matches (or tournament referee view). Click a match → score entry form (game scores array).
* **Score submission**: POST to API route that writes `match_scores` and updates `matches.winner` and `matches.status`. Validate scoring rules on the server (e.g., format: best of 3 to 11, win by 2) — for MVP keep the validation simple (e.g., accept submitted winner but do basic sanity checks).
* **Real-time updates**: use Supabase Realtime (listen to `matches` and `match_scores` changes) and update client UI instantly. In Next.js with `@supabase/supabase-js` you subscribe to table changes.

Example (client):

```ts
supabase
  .channel('public:matches')
  .on('postgres_changes', { event: '*', schema: 'public', table: 'matches', filter: `tournament_id=eq.${tournamentId}` }, payload => {
     // update local state
  })
  .subscribe()
```

---

# API endpoints (Next.js app router / serverless functions)

* `POST /api/tournaments` — create tournament
* `GET  /api/tournaments` — list tournaments
* `GET  /api/tournaments/[id]` — tournament detail (include matches & registrations)
* `POST /api/tournaments/[id]/register` — register player (or create player then registration)
* `POST /api/tournaments/[id]/generate` — generate bracket (call seeding + insert matches)
* `POST /api/matches/[id]/score` — submit score (server validates, updates match winner and status)

Server logic for `/generate`:

1. fetch registrations + player DUPR
2. sort (seed)
3. compute bracket with byes
4. upsert matches rows (round 1 and placeholder future rounds with round numbers)

---

# Minimal UI pages/components

1. **Home / Tournament list** — list tournaments, button "Create tournament"
2. **Create tournament modal** — name, date, format
3. **Tournament detail page** — left: bracket visualization (list of rounds), right: registrations + button `Generate bracket`

   * Bracket can be a simple table, not needed to be fancy (round columns with match rows)
4. **Player registration modal** — name, email, dupr
5. **Match detail / Referee page** — shows players, current status, score entry form, submit score
6. **Live updates** — subscribe to matches and scores and re-render

---

# Implementation order (step-by-step)

I give you a strict, do-this-next list so you can implement without decision paralysis. (I’m **not** giving time estimates — just the logical order.)

1. **Project skeleton**

   * `npx create-next-app@latest --ts` (or your preferred Next setup).
   * Install `@supabase/supabase-js`, `react-query` or SWR (optional), UI kit (headless UI / simple CSS).
   * Initialize Supabase project and connect via env vars.

2. **Database**

   * Run the SQL above in Supabase SQL editor to create tables.
   * Seed a couple of players manually in Supabase for local testing.

3. **Auth (minimal)**

   * Enable Supabase email auth or skip auth for MVP and allow anonymous actions (but at least set a simple admin key on server-side for sensitive endpoints). For referee flow, you can just open access for MVP and restrict later.

4. **Basic CRUD API**

   * Implement API endpoints: create tournament, list tournaments, create player, register. Use Supabase client on server (server-side) or call Supabase directly from client for simple ops.

5. **Tournament list & create**

   * UI to create a tournament and show list. Verify DB entries are created.

6. **Player registration**

   * UI to add/choose a player and register them into a tournament. Show the registrations on tournament page.

7. **Seeding & bracket generation**

   * Implement `/api/tournaments/[id]/generate`. Use the seeding function: sort by `dupr` desc, create match rows, insert into `matches`.
   * On the tournament page add a “Generate bracket” button to call the endpoint.

8. **Render bracket**

   * Simple rendering of rounds: query `matches` ordered by `round` and display pairings. Show `BYE` where player is null.
   * Implement automatic advancement for BYEs when generating matches (or after generation, set winners for BYE matches).

9. **Match detail & referee score submission**

   * Match page with a score form (games array). Implement `POST /api/matches/[id]/score` which:

     * writes `match_scores`
     * determines winner (server logic; or accept supplied winner after sanity checks)
     * updates `matches` `winner` and `status = finished`
     * also create next-round match entry if necessary and fill its slot with this winner (advance bracket)

10. **Real-time updates**

    * Setup Supabase Realtime subscription in the tournament detail component to listen for `matches` and `match_scores` changes and re-render the bracket/scoreboard.

11. **Polish**

    * Add small UI touches: show winner, highlight live matches, confirm dialogs, basic validation for scores.

12. **Quick testing**

    * Create a tournament, register 6–8 players, generate bracket, simulate match scores via Referee page, watch bracket advance via real-time updates.

---

# Server-side logic notes (important details)

* **Advancing winners**: when a match finishes, compute which downstream match/slot should be filled. Easiest approach: precreate all matches for the bracket with `source_match_id_a` and `source_match_id_b` columns referencing earlier-round matches. Then when a match has a winner, update the downstream match slot. (If you didn’t precreate, you can create next round matches on the fly.)
* **Match structure suggestion** (extra columns):

  * `source_match_a uuid`, `source_match_b uuid`, `slot_a_is_winner_of_source_a boolean` — helps to map progression robustly.
* **Score validation**: keep simple — require at least one game, and the final declared winner must have higher sum of games won. You can add strict pickleball rules later.
* **Transactions**: use DB transactions when writing match & score & advancing to avoid race conditions.

---

# Example: generate next-round match after a match finishes (pseudo)

1. Determine which match consumes this winner (precomputed mapping or compute by round and slot index).
2. `UPDATE matches SET slot_a = winner WHERE id = nextMatchId AND ...`
3. If both slots filled (slot_a && slot_b) set `status = scheduled`.

---

# Quick UI/UX tips (ship fast)

* Use forms + modals; avoid multi-step flows.
* Show DUPR next to players so users trust seeding.
* For referee score input: a single line per game (A score / B score) and a button “Submit match result.”
* Show confirmations and an “Undo” button (softly; the server can store last score entry and allow admin rollback).

---

Only use Tailwind + shadcn/ui